<!DOCTYPE html>
<html dir="ltr" lang="es">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0,viewport-fit=cover" />

<style>
  body {
    background-color: #060d21;
    color: green;
    font-family: monospace;
    margin: 30px;
  }

  .node {
    /* width: 320px; */
    width: auto;
    /* height: 200px; */
    border: green;
    border-style: solid;
    border-radius: 5px 5px 5px 5px;
    display: inline-block;
    margin-top: 5px;
    margin-right: 5px;
  }

  /* .nodeContent {
    margin: 10px;
    float: inherit;
  } */

  .text {
    margin-left: 10px;
    margin-right: 10px;
    margin-top: 7px;
    margin-bottom: 7px;
  }

  .localhost {
    color: white;
  }

  .mainbutton {
    border: 1px solid #268a16;
    border-radius: 6px;
    display: block;
    width: 100%;
    text-align: center;
    padding-top: 7px;
    padding-bottom: 7px;
    /* box-shadow: inset 0px 1px 0px 0px #caefab;
    background: linear-gradient(to bottom, #77d42a 5%, #5cb811 100%);
    background-color: #77d42a;
    display: inline-block;
    cursor: pointer;
    color: #306108;
    font-family: Arial;
    font-size: 15px;
    font-weight: bold;
    padding: 6px 24px;
    text-decoration: none;
    text-shadow: 0px 1px 0px #aade7c;
    text-align: center; */
  }

  /* .mainbutton:hover {
    background: linear-gradient(to bottom, #5cb811 5%, #77d42a 100%);
    background-color: #5cb811;
  } */

  /* .mainbutton:active {
    position: relative;
    top: 1px;
  } */

</style>

<body>
  <div id="main">
    <h1 id="title">Connecting...</h1>
  </div>
  <div id="boxes">
  </div>

  <div id="boxTemplate1" style="display: none;">
    <div class="nodeContent leftLabel">
      <div id="id-text" class="text">us-east-1</br>14ms</div>
    </div>
  </div>


</body>

<script>
  const module = {}
  let wrtc
</script>
<script src="simplepeer.min.js"></script>
<script src="peerNode/peer.js"></script>
<script src="peerNode/emojiHash.js"></script>
<script>
  const template1 = document.getElementById("boxTemplate1")

  function limitNumber(n) {
    return Math.floor(n * 100) / 100
  }

  function newPeer(peer, opts) {
    let peerId = peer.id
    console.log("NEW PEER HTML", peerId)
    let elem1 = document.createElement('div')
    elem1.classList = ['node']
    elem1.id = peerId

    let elem2 = document.createElement('div')


    let elem3 = document.createElement('div')
    elem3.classList = ['text']

    let name = document.createElement('div')
    elem3.append(name)
    name.style = "margin-bottom: 20px; font-size: 1.7em;"

    let latency = document.createElement('div')
    elem3.append(latency)
    latency.textContent = 'connecting...'

    let upload = document.createElement('div')
    elem3.append(upload)
    upload.style = "text-align: right;"

    let download = document.createElement('div')
    elem3.append(download)
    download.style = "text-align: right;"

    elem2.append(elem3)
    elem1.append(elem2)

    name.textContent = peer.id
    emojiHash(peerId, 7).then(hash => {
      name.textContent = hash
      peer.hashId = hash
    })

    if (peer.localhost) {
      elem2.classList = ['localhost']
      latency.textContent = peer.latency
      let downloadButton = document.createElement('a')
      downloadButton.id = "downloadButton"
      downloadButton.textContent = "Start Download"
      downloadButton.className = "mainbutton"
      downloadButton.style = "margin-top: 20px; width: 100%;"
      elem3.append(downloadButton)
      downloadButton.onclick = () => {
        if (peer.downloadStatus) {
          peer.stopDownloadFromPeers()
          downloadButton.textContent = "Start Download"
        } else {
          peer.startDownloadFromPeers()
          downloadButton.textContent = "Stop"
        }
      }
    }

    name.textContent = peer.id

    document.getElementById("boxes").appendChild(elem1)

    let tools = {
      updateSpeedStats: () => {
        peer.uploadUnits = "Kbps"
        let received = (peer.localhost ? peer.totalBufferSentCount : peer.totalBufferReceivedCount) * 8 / 1024
        let sent = (peer.localhost ? peer.totalBufferReceivedCount : peer.totalBufferSentCount) * 8 / 1024

        if (received > 1024) {
          received = received / 1024
          peer.uploadUnits = "Mbps"
        }
        peer.uploadSpeed = limitNumber(received / (peer.uiUpdateInterval / 1000))
        peer.totalBufferReceivedCount = 0

        peer.downloadUnits = "Kbps"
        if (sent > 1024) {
          sent = sent / 1024
          peer.downloadUnits = "Mbps"
        }

        peer.totalBufferSentCount = 0

        peer.uploadSpeed = limitNumber(received / (peer.uiUpdateInterval / 1000))
        peer.downloadSpeed = limitNumber(sent / (peer.uiUpdateInterval / 1000))


      },
      render: () => {
        tools.updateSpeedStats()

        download.textContent = peer.downloadSpeed + " " + peer.downloadUnits + " ðŸ”½"
        upload.textContent = peer.uploadSpeed + " " + peer.uploadUnits + " ðŸ”¼"
        // if (!isNaN(peer.latency)) {
        // let latency = peer.latency == 0 ? '< 1' : peer.latency
        latency.textContent = peer.latency + "."
        setTimeout(() => {
          latency.textContent = peer.latency
        }, 100)
        // }
      },
      remove: () => {
        elem1.style = "display: none;"
      }
    }

    setInterval(tools.render, peer.uiUpdateInterval)
    tools.render()

    return tools
  }

  peerNode(SimplePeer,
    WebSocket,
    wrtc,
    {
      newPeer
    })

  // for (let i = 0; i < 3; i++) {
  //   newPeer(i)
  // }

</script>

</html>
