<!DOCTYPE html>
<html dir="ltr" lang="es">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0,viewport-fit=cover" />
<!-- Google Tag Manager -->
<script>(function (w, d, s, l, i) {
    w[l] = w[l] || []; w[l].push({
      'gtm.start':
        new Date().getTime(), event: 'gtm.js'
    }); var f = d.getElementsByTagName(s)[0],
      j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : ''; j.async = true; j.src =
        'https://www.googletagmanager.com/gtm.js?id=' + i + dl; f.parentNode.insertBefore(j, f);
  })(window, document, 'script', 'dataLayer', 'GTM-WXPVPP6Z');</script>
<!-- End Google Tag Manager -->
<style>
  body {
    background-color: #1c2230;
    color: white;
    font-family: monospace;
    margin: 30px;
  }

  .connectButton {
    font-size: 0.8em;
  }

  .peerButtons {
    display: inline-block;
    /* float: right; */
  }

  .displayBlock {
    display: block;
    cursor: pointer;
  }

  .inlineBlock {
    display: inline-block;
    margin-left: 10px;
  }

  .hidden {
    display: none;
  }

  .dotted {
    border: dotted 3px #000000;
  }

  table {
    border-collapse: collapse;

    /*This property collapses borders together*/
  }

  .boxes {
    color: white;
  }

  .mainTable {
    width: 100%;
    margin-top: 20px;
    border-collapse: collapse;
    /* border: 1px solid; */
    color: gray;
  }

  table,
  th,
  td {
    border: 1px solid;
    border-color: #192648;
    border-color: #060d21
  }

  .alignRight {
    text-align: right;
  }

  .latencyColumn {
    /* width: 150px; */
    display: flex;
    justify-content: space-between
  }

  .nickColumn {
    /* width: 100px; */
    /* min-width: 110px; */
    /* font-size: 1.5em; */
  }

  .cursive {
    /* font-size: 0.8em; */
    /* font-style: italic; */
  }

  .nameColumn {
    font-size: 1.5em;
    width: 110px;
    min-width: 100px;
  }

  .downloadColumn {
    text-align: right;
    min-width: 100px;
    width: 100px;
  }

  .uploadColumn {
    text-align: right;
    min-width: 100px;
    width: 100px;
  }

  .node {
    background-color: #1b2334;
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    justify-content: space-between;
    align-items: center;
    align-content: space-around;
  }

  .infoTable {
    /* width: 30%; */
    /* min-width: 200px; */
    /* display: inline-block; */
    order: 5;
    flex-grow: 1;
    flex-basis: 30%;
    /* flex-shrink: 10; */
  }

  .latencyTd {
    width: 60px;
  }

  .nameTd {
    width: 170px;
    min-width: 170px;
  }



  .connectTable {
    /* width: 30%; */
    /* min-width: 200px; */
    /* display: inline-block; */
    order: 6;
    flex-grow: 1;
    flex-basis: 200px;
    flex-basis: 30%;
  }

  .speedTable {
    /* width: auto; */
    /* min-width: 200px; */
    /* display: inline-block; */
    order: 7;
    flex-grow: 1;
    flex-basis: 30%;
  }

  /* .floatRight {
    /* float: right; */
  /* display: block;
    margin-left: auto;
    margin-right: 0; */
  /* flex-grow: 1; */
  /* text-align: right */
  /* position: absolute; */
  /* right: 0; */
  /* } */

  .maxSpeed {
    font-size: 1.5em;
    font-weight: 800;
    color: white;
  }

  .terminalButtons {
    margin: 20px;
  }

  .terminal {
    padding: 7px;
    margin-top: 15px;
    border: green;
    /* border-style: solid; */
    border-radius: 5px 5px 5px 5px;
    overflow: auto;
    background-color: #060d21;
  }

  .tdSpeed {
    width: 100px;
    text-align: right;
  }

  .node2 {
    /* width: 320px; */
    width: auto;
    /* height: 200px; */
    /* border: green; */
    /* border-style: solid; */
    background-color: #1b2334;
    /* border-radius: 5px 5px 5px 5px; */
    /* display: inline-block; */
    margin-top: 5px;
    margin-right: 5px;
    vertical-align: top;
    /* display: flex; */
    /* flex-direction: row; */
    /* align-items:left; */
    position: relative;
    display: flex;
    justify-content: space-between;
  }

  .title {
    font-weight: 800;
  }


  /* .nodeLine { */
  /* display: flex; */
  /* display: inline-block; */
  /* flex-grow: 1; */
  /* flex-direction: row; */
  /* } */

  .mainTerminal {
    color: white;
    padding: 10px;
  }

  .terminalLine {
    /* position: relative;
    left: 0;
    width: 200vw; */
    color: #7a7a7a;
    white-space: nowrap;
  }

  .terminalLineDestination {
    color: white;
  }

  .whiteNode {
    /* width: 320px; */
    width: auto;
    /* height: 200px; */
    border: white;
    border-style: solid;
    /* border-radius: 5px 5px 5px 5px; */
    display: inline-block;
    margin-top: 5px;
    margin-right: 5px;
  }

  /* .nodeContent {
    margin: 10px;
    float: inherit;
  } */

  .pointer {
    cursor: pointer;
  }

  .text {
    margin-left: 10px;
    margin-right: 10px;
    margin-top: 7px;
    margin-bottom: 7px;
  }

  .localhost {
    color: white;
  }



  /* .name {
    min-width: 100px;
  } */

  .mainButton {
    cursor: pointer;
    /* border: 1px solid #268a16; */
    color: black;
    background-color: white;
    border-radius: 6px;
    display: inline-block;
    text-align: center;
    padding: 7px;
    margin-right: 5px;
  }

  .disabledButton {
    background-color: gray;
  }

  .mainButtonDisabled {
    cursor: pointer;
    border: 0px;
    border-radius: 6px;
    display: block;
    width: 100%;
    text-align: center;
    padding: 7px;
    /* padding-bottom: 7px; */
    margin-top: 10px;
    width: 100%;
  }

  .pressAny {}

  .blink {
    animation: blinker 1.5s linear infinite;
    color: greenyellow;
  }

  .runningTest {
    /* color: orange; */
  }

  @keyframes blinker {
    50% {
      opacity: 0;
    }
  }

  /* .mainButton:hover {
    background: linear-gradient(to bottom, #5cb811 5%, #77d42a 100%);
    background-color: #5cb811;
  } */

  /* .mainButton:active {
    position: relative;
    top: 1px;
  } */
</style>

<body>
  <!-- Google Tag Manager (noscript) -->
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WXPVPP6Z" height="0" width="0"
      style="display:none;visibility:hidden"></iframe></noscript>
  <!-- End Google Tag Manager (noscript) -->
  <div id="main">
    <h2 id="maxUpload"></h2>
    <!-- <h2 id="maxDownload"></h2> -->

  </div>
  <div id="mainTerminal" class="terminal">
    <div>
      $ speed-test --webrtc=enabled
    </div>
    <div id="boxes" style="display: inline; ">
      <table id="mainTable" class="mainTable">
        <tr style="font-weight: 800;">
          <td>Name</td>
          <td>Description</td>
          <td class="alignRight">Upload</td>
          <td class="alignRight">Download</td>
        </tr>
      </table>
    </div>
    <div id="add" class="terminalButtons" style="display: inline-block;">
      <div id="pressAny" class="pressAny blink">Press any key to start test</div>
      <!-- <a id="wakeUpPeers" class="mainButton">➕ Wake up WebRTC Peers</a>
      <a id="startbutton" class="mainButton">▶️ START SPEED-TEST</a> -->
    </div>
    <!-- <div id="pressP" class="pressAny">Press P to wake up cloud peers for WebRTC speed tests.</div> -->
  </div>



  <div id="boxTemplate1" style="display: none;">
    <div class="nodeContent leftLabel">
      <div id="id-text" class="text">us-east-1</br>14ms</div>
    </div>
  </div>
  <div style="margin-left: 5px;">
    <h2>Readme</h2>
    <h3>Speed-test</h3>
    <p>Open this page in different browsers and connect between them to test download speeds through WebRTC P2P
      protocol.</p>
    <p>To test with cloud hosted <b>WebRTC</b> Peers, click on the "Wake up WebRTC Peers" button.</p>
    <p>"Start Speed-test button": Triggers a normal download from 6 simultaneous CDN services.</p>
    <h3>Traceroute</h3>
    <p>Detailed reverse-traceroute from different AWS regions to your public IP:</p>
  </div>

  <div id="traceroutes" style="display: inline; ">
  </div>
</body>

<script>
  const module = {}
  let wrtc
  const generalUIUpdateInterval = 1000
  let cdnPeersSending = 0
</script>
<script src="simplepeer.min.js"></script>
<script src="get.js"></script>
<script src="peerNode/peer.js"></script>
<script src="peerNode/emojiHash.js"></script>
<script src="peerNode/traceroute.js"></script>
<script>
  const template1 = document.getElementById("boxTemplate1")
  let maxUpload = document.getElementById("maxUpload")
  // let maxDownload = document.getElementById("maxDownload")

  let myPeer
  function limitNumber(n) {
    return Math.floor(n * 100) / 100
  }

  function parseSpeed(value) {
    let units = "Kbps"
    let unit = "KB"
    if (value > 1024) {
      value = parseInt(value / 1024)
      units = "Mbps"
      unit = "MB"
    }
    // if (value > 1024) {
    //   received = parseInt(value / 1024)
    //   units = "Gbps"
    // }
    return { value: Math.floor(value * 100) / 100, units, unit }
  }

  let localIp
  let maxDownload
  function newPeer(peer, opts) {
    let peerId = peer.id

    let tableRow = document.createElement('tr')

    let nickCol = document.createElement('td')
    let nick = document.createElement('span')
    nickCol.appendChild(nick)
    nickCol.classList.add("nickColumn")
    tableRow.appendChild(nickCol)

    // let name = document.createElement('td')
    // tableRow.appendChild(name)
    // name.classList.add("nameColumn")

    let description = document.createElement('td')
    let type = document.createElement('div')
    type.classList.add("title")
    let latency = document.createElement('div')
    description.appendChild(type)
    description.appendChild(latency)

    let totals = document.createElement('div')
    totals.classList.add("inlineBlock")
    description.appendChild(totals)


    if (peer.localhost) {
      let maxs = document.createElement('span')
      let maxsLabel = document.createElement('div')
      maxsLabel.classList.add("inlineBlock")

      maxDownload = document.createElement('div')
      maxsLabel.textContent = "Peak Speed: "
      maxsLabel.style = "margin-right: 7px;"
      maxDownload.textContent = "0 Mbps"
      maxDownload.classList.add("inlineBlock")
      maxDownload.classList.add("maxSpeed")

      maxs.appendChild(maxsLabel)
      maxs.appendChild(maxDownload)
      description.appendChild(maxs)
    }

    if (peer.localhost) {
      let avgs = document.createElement('span')
      let avgsLabel = document.createElement('div')
      avgsLabel.classList.add("inlineBlock")

      avgDownload = document.createElement('div')
      avgsLabel.textContent = "Average: "
      avgsLabel.style = "margin-right: 7px;"
      avgDownload.textContent = "0 Mbps"
      avgDownload.classList.add("inlineBlock")
      avgDownload.classList.add("maxSpeed")

      avgs.appendChild(avgsLabel)
      avgs.appendChild(avgDownload)
      description.appendChild(avgs)
    }

    description.classList.add("latencyColumn")
    tableRow.appendChild(description)

    let downloadSpace = document.createElement('td')
    let uploadSpace = document.createElement('td')
    uploadSpace.classList.add("uploadColumn")
    downloadSpace.classList.add("downloadColumn")

    let connect = document.createElement('div')
    description.appendChild(connect)

    let downloadBtn = document.createElement('div')
    let breakTag = document.createElement('br')

    let download = document.createElement('div')
    let upload = document.createElement('span')

    description.appendChild(downloadBtn)
    uploadSpace.appendChild(download)

    downloadSpace.appendChild(upload)

    tableRow.appendChild(downloadSpace)
    tableRow.appendChild(uploadSpace)

    nick.textContent = peer.nick

    latency.textContent = '...'
    let connectButton
    let downloadButton

    if (peer.cdn) {
      nick.classList.add("cursive")
      // upload.classList.remove("hidden")
    } else {
      // upload.classList.add("hidden")
      // download.classList.add("hidden")
    }

    if (peer.localhost) {
      localIp = document.createElement('div')
      description.appendChild(localIp)
      latency.classList.add("hidden")
    }

    if (!peer.localhost && !peer.cdn) {
      type.textContent = "WebRTC Peer"
      connectButton = document.createElement('a')
      description.appendChild(connectButton)
      connectButton.classList.add("mainButton")
      connectButton.classList.add("peerButtons")

      connectButton.textContent = "Connect"
      connectButton.onclick = () => {
        console.log("ENABLE UPLOAD")
        connectButton.textContent = "Connected"
        connect.classList.add("hidden")
        upload.classList.remove("hidden")
        // connectButton.className = "mainButtonDisabled"
        peer.enableUpload()
      }
      downloadButton = document.createElement('a')
      description.appendChild(downloadButton)

      downloadButton.id = "downloadButton"
      downloadButton.classList.add("mainButton")
      connectButton.classList.add("peerButtons")
      downloadButton.classList.add("disabledButton")
      downloadButton.textContent = "Download"

      downloadButton.onclick = () => {
        if (peer.downloadStatus) {
          peer.stopDownloadFromPeer()
        } else {
          peer.startDownloadFromPeer()
        }
      }
    } else {

      // elem1.className = "whiteNode"
      // elem1.style = "font-size: 1.7em;"
      // elem1.style = "font-size: 3em;"
    }

    if (peer.id) {
      nick.textContent = peer.id
      emojiHash(peerId, 5).then(hash => {
        nick.textContent = hash
        peer.hashId = hash
      })
    } else {
      // name.textContent = "⬜️⬜️⬜️⬜️⬜️"
    }

    document.getElementById("mainTable").appendChild(tableRow)

    let tools = {
      setHashId: () => {
        emojiHash(peer.id, 5).then(hash => {
          nick.textContent = hash
        })
      },
      updateDownloadButton: () => {
        if (downloadButton) {
          // console.log("<<< updateDownloadButton >>>", peer.downloadStatus, downloadButton)
          if (peer.downloadStatus) {
            downloadButton.textContent = "Stop"
          } else {
            downloadButton.textContent = "Download"
          }
        }
      },
      updateSpeedStats: () => {
        peer.uploadUnits = "Kbps"
        let received = 0
        let sent = 0

        if (peer.localhost && peer.cdnPeers) {
          peer.cdnPeers.forEach((cdnPeer) => {
            received += cdnPeer.cdnDownload
          })
          peer.cdnPeers.forEach((cdnPeer) => {
            sent += cdnPeer.cdnUpload
          })
        }

        if (peer.cdn) {
          received += peer.cdnUpload
        } else {
          received += (peer.localhost ? peer.totalBufferSentCount : peer.totalBufferReceivedCount) * 8 / 1024
        }

        if (peer.cdn) {
          sent += peer.cdnDownload
        } else {
          sent += (peer.localhost ? peer.totalBufferReceivedCount : peer.totalBufferSentCount) * 8 / 1024
        }

        if (peer.lastSpeedCalculation) {
          sent = sent * 1000 / (new Date() - peer.lastSpeedCalculation)
          received = received * 1000 / (new Date() - peer.lastSpeedCalculation)
        }

        let sentParsed = parseSpeed(sent)
        peer.downloadSpeed = sentParsed.value
        peer.downloadUnits = sentParsed.units

        let receivedParsed = parseSpeed(received)
        peer.uploadSpeed = receivedParsed.value
        peer.uploadUnits = receivedParsed.units

        peer.totalBufferSentCount = 0
        peer.totalBufferReceivedCount = 0

        peer.lastSpeedCalculation = new Date()


      },
      render: () => {
        tools.updateSpeedStats()

        if (peer.uploadToken && !peer.localhost) {
          // downloadButton.style = ""
          downloadButton.classList.remove("disabledButton")
          download.classList.remove("hidden")
        }

        if (peer.downloadLoadedBytes) {
          let parsed = parseSpeed(peer.downloadLoadedBytes * 1024)
          download.textContent += ` ${parsed.value}${parsed.unit}`
        }
        if (peer.cdn) {
          if (peer.downloadTotalBytes) {
            let parsedTotal = parseSpeed(peer.downloadTotalBytes * 1024)
            let parsedUpload = parseSpeed(peer.downloadLoadedBytes * 1024)
            totals.textContent = `${parsedUpload.value} ${parsedUpload.unit}/${parsedTotal.value} ${parsedTotal.unit}`
          }
        }

        download.textContent = peer.downloadSpeed + " " + peer.downloadUnits
        upload.textContent = peer.uploadSpeed + " " + peer.uploadUnits

        if (peer.localhost) {
          if (peer.downloadSpeed > peer.maxDownloadSpeed) {
            peer.maxDownloadSpeed = peer.downloadSpeed
            if (maxDownload) maxDownload.textContent = download.textContent
          }
          if (peer.uploadSpeed > peer.maxUploadSpeed) {
            peer.maxUploadSpeed = peer.uploadSpeed
            maxUpload.textContent = upload.textContent
          }

          peer.downloadHistoric = peer.downloadHistoric || []

          let average = 0
          if (peer.downloadSpeed > 0) {
            peer.downloadHistoric.push(peer.downloadSpeed)
            average = peer.downloadHistoric.map((speed) => {
              return speed
            }).reduce((a, b) => {
              return a + b
            }, 0) / peer.downloadHistoric.length

            avgDownload.textContent = (Math.floor(average) || 0) + " " + peer.downloadUnits
          }

          type.textContent = "localhost"
        } else {
          if (!peer.cdn) {
            latency.textContent = peer.latency + "."
            setTimeout(() => {
              latency.textContent = peer.latency
            }, 200)
          } else {
            latency.textContent = peer.latency
          }
        }

      },
      remove: () => {
        tableRow.classList.add("hidden")
      },
      updateNick: () => {
        console.log("UPDATE NICK!", peer.nick)
        nick.textContent = peer.nick
        if (peer.isServer) {
          connect.textContent = "Connected"
        }
      }
    }

    setInterval(tools.render, peer.uiUpdateInterval)
    tools.render()

    return tools
  }

  myPeer = peerNode(
    SimplePeer,
    WebSocket,
    wrtc,
    {
      newPeer,
    },
    {
      myNick: "localhost"
    })

  let limitPeers = localStorage.getItem('limitPeers');

  // wakeUpPeers = document.getElementById("wakeUpPeers")

  wakeUpPeers = () => {
    if (!document.peersRequested) {

      let alreadyRequested = sessionStorage.getItem('limitPeers');

      if (alreadyRequested) {
        document.getElementById("pressP").textContent = "WebRTC peers already requested!"
      } else {
        document.peersRequested = true
        // if (!limitPeers) {

        document.getElementById("pressP").textContent = "WebRTC peers requested!"

        setTimeout(() => {
          // wakeUpPeers.style = "display: none;"
          document.getElementById("pressP").style = "display: none;"
        }, 5000)

        fetch("https://atrqipagi3.execute-api.eu-west-3.amazonaws.com/dev/init")
        limitPeers = true
        sessionStorage.setItem('limitPeers', true);
      }



      // } else {
      // wakeUpPeers.textContent = "Request sent!"

      // wakeUpPeers.textContent = "😞 rate-limit reached"

      // }
    }
  }


  // let startButton = document.getElementById("startbutton")
  // startButton.onclick = () => {
  //   // console.log("START! (24MB)")
  //   startButton.textContent = "🔁 Repeat Test"
  //   myPeer.cdnPeers.forEach((peer) => {
  //     peer.startDownloadFromCDN()
  //   })
  // }

  function startTest(e) {
    e = e || window.event;
    console.log("KEYPRESS", e.keyCode)

    if (e.keyCode === 112 || e.keyCode === 80) {
      wakeUpPeers()
      return
    }

    if (!document.speedStarted) {
      document.speedStarted = true
      myPeer.cdnPeers.forEach((peer) => {
        peer.startDownloadFromCDN()
      })
      document.getElementById("pressAny").classList.add("runningTest")
      document.getElementById("pressAny").innerHTML = "Running test..."
    }

    if (e.keyCode == 32 && e.target == document.body) {
      e.preventDefault();
    }
    // use e.keyCode
  };

  document.speedStarted = false
  document.peersRequested = false
  document.onkeypress = startTest
  document.ontouchstart = startTest
  document.onclick = startTest

  function testCompleted() {
    document.getElementById("pressAny").innerHTML = "Test completed"
    document.getElementById("pressAny").classList.remove("blink")
  }

  // for (let i = 0; i < 3; i++) {
  //   newPeer(i)
  // }

</script>
<script src="cdnPeers.js"></script>
<script>
  get("https://utils.s.r3js.com/geo").then(geo => {
    console.log("GEO", geo)
    localIp.textContent = `You public ip is: ${geo.ip}`
    traceroute(geo)
  })
</script>

</html>